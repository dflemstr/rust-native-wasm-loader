import { execAsync } from 'async-child-process';
import fse from 'fs-extra';
import loaderUtils from 'loader-utils';
import os from 'os';
import path from 'path';
import ab2str from 'arraybuffer-to-string';
import semver from 'semver';

const findSrcDir = async function(childPath) {
  let candidate = childPath;

  while (candidate !== path.parse(candidate).root) {
    const maybeCargoFile = path.join(candidate, 'Cargo.toml');
    if (await fse.pathExists(maybeCargoFile)) {
      return candidate;
    }
    candidate = path.dirname(candidate);
  }

  return null;
};

const DEFAULT_OPTIONS = {
  release: false,
  gc: false,
  target: 'wasm32-unknown-unknown',
  cargoWeb: false,
  regExp: undefined,
};

const REQUIRED_CARGO_WEB_VERSION = '>=0.6.8';

const loadCargoWeb = async function(self, opts, srcDir) {
  const release = opts.release;
  const target = opts.target;

  const cargoWebVersionResult = await execAsync('cargo-web --version', {cwd: srcDir});
  const actualCargoWebVersion = semver.parse(cargoWebVersionResult.stdout.split(' ')[1].trim());

  if (!semver.satisfies(actualCargoWebVersion, REQUIRED_CARGO_WEB_VERSION)) {
    throw new Error(
      `Incompatible cargo-web version; need ${REQUIRED_CARGO_WEB_VERSION} but got ${actualCargoWebVersion}`);
  }

  const cmd = ['cargo', 'web', 'build', '--message-format=json',
               '--runtime=experimental-only-loader', '--target=' + target];
  if (release) {
    cmd.push('--release');
  }

  const result = await execAsync(cmd.join(' '), {cwd: srcDir});

  const {wasmFile, jsFile} = handleCargo(self, result);

  if (!wasmFile) {
    throw new Error('No wasm file produced as build output');
  }
  if (!jsFile) {
    throw new Error('No js file produced as build output');
  }

  // This contains an __initialize function
  const jsData = await fse.readFile(jsFile);

  return `// Generated by rust-native-wasm-loader
var loadWasm = require(${JSON.stringify(wasmFile)});
${jsData}
module.exports = loadWasm().then(function (result) {
  return __initialize(result.module);
});
`;
};

const loadRaw = async function(self, opts, srcDir) {
  const release = opts.release;
  const gc = opts.gc;
  const target = opts.target;

  const cmd = ['cargo', 'build', '--message-format=json', '--target=' + target];
  if (release) {
    cmd.push('--release');
  }

  const result = await execAsync(cmd.join(' '), {cwd: srcDir});

  let {wasmFile} = handleCargo(self, result);

  if (!wasmFile) {
    throw new Error('No wasm file produced as build output');
  }

  if (gc) {
    let gcWasmFile = wasmFile.substr(0, wasmFile.length - '.wasm'.length) + '.gc.wasm';
    await execAsync(`wasm-gc ${wasmFile} ${gcWasmFile}`);
    wasmFile = gcWasmFile;
  }

  return await fse.readFile(wasmFile);
};

const handleCargo = function(self, result) {
  let wasmFile;
  let jsFile;
  outer: for (let line of result.stdout.split(os.EOL)) {
    if (/^\s*$/.test(line)) {
      continue;
    }
    const data = JSON.parse(line);
    switch (data.reason) {
      case 'compiler-message':
        switch (data.message.level) {
          case 'warning':
            self.emitWarning(new Error(data.message.rendered));
            break;
          case 'error':
            self.emitError(new Error(data.message.rendered));
            break;
        }
        break;
      case 'compiler-artifact':
        if (!wasmFile) {
          wasmFile = data.filenames.find((p) => p.endsWith('.wasm'));
        }
        if (!jsFile) {
          jsFile = data.filenames.find((p) => p.endsWith('.js'));
        }
        if (wasmFile) {
          break outer;
        }
        break;
    }
  }
  return {wasmFile, jsFile};
};

const load = async function(self) {
  const srcDir = await findSrcDir(self.resourcePath);
  if (!srcDir) {
    throw new Error('No Cargo.toml file found in any parent directory.');
  }

  const opts = Object.assign({}, DEFAULT_OPTIONS, loaderUtils.getOptions(self));
  const cargoWeb = opts.cargoWeb;

  if (cargoWeb) {
    return await loadCargoWeb(self, opts, srcDir);
  } else {
    return await loadRaw(self, opts, srcDir);
  }
};

export default function() {
  const callback = this.async();
  load(this).then(r => callback(null, r), e => callback(e, null));
};
